import _createForOfIteratorHelperLoose from "@babel/runtime/helpers/createForOfIteratorHelperLoose";
import {
  useLayoutEffect as _,
  startTransition,
  useCallback,
  useEffect,
  useMemo,
  useReducer,
  useRef
} from "react";
import useRefEffect from "../useRefEffect";
import { AnimatedEvent } from "./AnimatedEvent";
import NativeAnimatedHelper from "./NativeAnimatedHelper";
import AnimatedProps from "./nodes/AnimatedProps";
const useLayoutEffect = typeof window === "undefined" ? useEffect : _;
function useAnimatedProps(props) {
  var _useReducer = useReducer((count) => count + 1, 0), scheduleUpdate = _useReducer[1];
  var onUpdateRef = useRef(null);
  var node = useMemo(
    () => new AnimatedProps(
      props,
      () => onUpdateRef.current == null ? void 0 : onUpdateRef.current()
    ),
    [props]
  );
  useAnimatedPropsLifecycle(node);
  var refEffect = useCallback(
    (instance) => {
      node.setNativeView(instance);
      onUpdateRef.current = () => {
        startTransition(() => {
          scheduleUpdate();
        });
      };
      var target = getEventTarget(instance);
      var events = [];
      for (var propName in props) {
        var propValue = props[propName];
        if (propValue instanceof AnimatedEvent && propValue.__isNative) {
          propValue.__attach(target, propName);
          events.push([propName, propValue]);
        }
      }
      return () => {
        onUpdateRef.current = null;
        for (var _iterator = _createForOfIteratorHelperLoose(events), _step; !(_step = _iterator()).done; ) {
          var _step$value = _step.value, _propName = _step$value[0], _propValue = _step$value[1];
          _propValue.__detach(target, _propName);
        }
      };
    },
    [props, node]
  );
  var callbackRef = useRefEffect(refEffect);
  return [reduceAnimatedProps(node), callbackRef];
}
function reduceAnimatedProps(node) {
  return {
    ...node.__getValue(),
    collapsable: false
  };
}
function useAnimatedPropsLifecycle(node) {
  var prevNodeRef = useRef(null);
  var isUnmountingRef = useRef(false);
  useEffect(() => {
    NativeAnimatedHelper.API.flushQueue();
  });
  useLayoutEffect(() => {
    isUnmountingRef.current = false;
    return () => {
      isUnmountingRef.current = true;
    };
  }, []);
  useLayoutEffect(() => {
    node.__attach();
    if (prevNodeRef.current != null) {
      var prevNode = prevNodeRef.current;
      prevNode.__restoreDefaultValues();
      prevNode.__detach();
      prevNodeRef.current = null;
    }
    return () => {
      if (isUnmountingRef.current) {
        node.__detach();
      } else {
        prevNodeRef.current = node;
      }
    };
  }, [node]);
}
function getEventTarget(instance) {
  return typeof instance === "object" && typeof (instance == null ? void 0 : instance.getScrollableNode) === "function" ? instance.getScrollableNode() : instance;
}
function isFabricInstance(instance) {
  var _instance$getScrollRe;
  return hasFabricHandle(instance) || // Some components have a setNativeProps function but aren't a host component
  // such as lists like FlatList and SectionList. These should also use
  // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying
  // host component. This crazy hack is essentially special casing those lists and
  // ScrollView itself to use forceUpdate in Fabric.
  // If these components end up using forwardRef then these hacks can go away
  // as instance would actually be the underlying host component and the above check
  // would be sufficient.
  hasFabricHandle(
    instance == null ? void 0 : instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()
  ) || hasFabricHandle(
    instance == null ? void 0 : instance.getScrollResponder == null ? void 0 : (_instance$getScrollRe = instance.getScrollResponder()) == null ? void 0 : _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef()
  );
}
function hasFabricHandle(instance) {
  var _instance$_internalIn, _instance$_internalIn2;
  return (instance == null ? void 0 : (_instance$_internalIn = instance["_internalInstanceHandle"]) == null ? void 0 : (_instance$_internalIn2 = _instance$_internalIn.stateNode) == null ? void 0 : _instance$_internalIn2.canonical) != null;
}
export {
  useAnimatedProps as default
};
//# sourceMappingURL=useAnimatedProps.js.map
