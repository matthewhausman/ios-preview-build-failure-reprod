import { jsx } from "react/jsx-runtime";
import { usePressEvents } from "@tamagui/react-native-use-pressable";
import * as React from "react";
import { forwardRef, memo, useMemo, useRef, useState } from "react";
import { StyleSheet } from "react-native-web-internals";
import { useHover, useMergeRefs } from "react-native-web-internals";
import View from "../View/index";
function Pressable(props, forwardedRef) {
  const {
    children,
    delayLongPress,
    delayPressIn,
    delayPressOut,
    disabled,
    focusable,
    onBlur,
    onContextMenu,
    onFocus,
    onHoverIn,
    onHoverOut,
    onKeyDown,
    onLongPress,
    onPress,
    onPressMove,
    onPressIn,
    onPressOut,
    style,
    testOnly_hovered,
    testOnly_pressed,
    ...rest
  } = props;
  const [hovered, setHovered] = useForceableState(testOnly_hovered === true);
  const [focused, setFocused] = useForceableState(false);
  const [pressed, setPressed] = useForceableState(testOnly_pressed === true);
  const hostRef = useRef(null);
  const setRef = useMergeRefs(forwardedRef, hostRef);
  const pressConfig = useMemo(
    () => ({
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      disabled,
      onLongPress,
      onPress,
      onPressChange: setPressed,
      onPressStart: onPressIn,
      onPressMove,
      onPressEnd: onPressOut
    }),
    [
      delayLongPress,
      delayPressIn,
      delayPressOut,
      disabled,
      onLongPress,
      onPress,
      onPressIn,
      onPressMove,
      onPressOut,
      setPressed
    ]
  );
  const pressEventHandlers = usePressEvents(hostRef, pressConfig);
  const { onContextMenu: onContextMenuPress, onKeyDown: onKeyDownPress } = pressEventHandlers;
  useHover(hostRef, {
    contain: true,
    disabled,
    onHoverChange: setHovered,
    onHoverStart: onHoverIn,
    onHoverEnd: onHoverOut
  });
  const interactionState = { hovered, focused, pressed };
  const blurHandler = React.useCallback(
    (e) => {
      if (disabled) {
        return;
      }
      if (e.nativeEvent.target === hostRef.current) {
        setFocused(false);
        if (onBlur != null) {
          onBlur(e);
        }
      }
    },
    [disabled, hostRef, setFocused, onBlur]
  );
  const focusHandler = React.useCallback(
    (e) => {
      if (disabled) {
        return;
      }
      if (e.nativeEvent.target === hostRef.current) {
        setFocused(true);
        if (onFocus != null) {
          onFocus(e);
        }
      }
    },
    [disabled, hostRef, setFocused, onFocus]
  );
  const contextMenuHandler = React.useCallback(
    (e) => {
      if (onContextMenuPress != null) {
        onContextMenuPress(e);
      }
      if (onContextMenu != null) {
        onContextMenu(e);
      }
    },
    [onContextMenu, onContextMenuPress]
  );
  const keyDownHandler = React.useCallback(
    (e) => {
      if (onKeyDownPress != null) {
        onKeyDownPress(e);
      }
      if (onKeyDown != null) {
        onKeyDown(e);
      }
    },
    [onKeyDown, onKeyDownPress]
  );
  return /* @__PURE__ */ jsx(
    View,
    {
      ...rest,
      ...pressEventHandlers,
      accessibilityDisabled: disabled,
      focusable: !disabled && focusable !== false,
      onBlur: blurHandler,
      onContextMenu: contextMenuHandler,
      onFocus: focusHandler,
      onKeyDown: keyDownHandler,
      pointerEvents: disabled ? "none" : rest.pointerEvents,
      ref: setRef,
      style: [
        !disabled && styles.root,
        typeof style === "function" ? style(interactionState) : style
      ],
      children: typeof children === "function" ? children(interactionState) : children
    }
  );
}
function useForceableState(forced) {
  const [bool, setBool] = useState(false);
  return [bool || forced, setBool];
}
const styles = StyleSheet.create({
  root: {
    cursor: "pointer",
    touchAction: "manipulation"
  }
});
const MemoedPressable = memo(forwardRef(Pressable));
MemoedPressable.displayName = "Pressable";
var Pressable_default = MemoedPressable;
export {
  Pressable_default as default
};
//# sourceMappingURL=index.js.map
