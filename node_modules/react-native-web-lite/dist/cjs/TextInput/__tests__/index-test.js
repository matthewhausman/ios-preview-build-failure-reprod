"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var import_jsx_runtime = require("react/jsx-runtime");
var import_react = require("@testing-library/react");
var import_dom_event_testing_library = require("dom-event-testing-library");
var import_react2 = __toESM(require("react"));
var import_test_utils = require("react-dom/test-utils");
var import__ = __toESM(require(".."));
function findInput(container) {
  return container.querySelector("input");
}
function findTextArea(container) {
  return container.querySelector("textarea");
}
const testIfDocumentIsFocused = (message, fn) => {
  if (document.hasFocus && document.hasFocus()) {
    test(message, fn);
  } else {
    test.skip(`${message} \u2013 document is not focused`, () => {
    });
  }
};
function createEvent(type, data = {}) {
  const event = document.createEvent("CustomEvent");
  event.initCustomEvent(type, true, true);
  if (data != null) {
    Object.keys(data).forEach((key) => {
      const value = data[key];
      if (key === "timeStamp" && !value) {
        return;
      }
      Object.defineProperty(event, key, { value });
    });
  }
  return event;
}
function createKeyboardEvent(type, {
  altKey = false,
  ctrlKey = false,
  isComposing = false,
  key = "",
  keyCode = 0,
  metaKey = false,
  preventDefault = () => {
  },
  shiftKey = false
} = {}) {
  return createEvent(type, {
    altKey,
    ctrlKey,
    isComposing,
    key,
    keyCode,
    metaKey,
    preventDefault,
    shiftKey
  });
}
function keydown(payload) {
  return createKeyboardEvent("keydown", payload);
}
describe("components/TextInput", () => {
  describe('prop "autoComplete"', () => {
    test('value "on"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, {}));
      const input = findInput(container);
      expect(input.getAttribute("autoComplete")).toEqual("on");
    });
    test('value "off"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { autoComplete: "off" }));
      const input = findInput(container);
      expect(input.getAttribute("autoComplete")).toEqual("off");
    });
    test("autoCompleteType fallback", () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { autoCompleteType: "off" }));
      const input = findInput(container);
      expect(input.getAttribute("autoComplete")).toEqual("off");
    });
  });
  describe('prop "autoFocus"', () => {
    test('value "false"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, {}));
      const input = findInput(container);
      expect(document.activeElement).not.toBe(input);
    });
    test('value "true"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { autoFocus: true }));
      const input = findInput(container);
      expect(document.activeElement).toBe(input);
    });
  });
  describe('prop "clearTextOnFocus"', () => {
    const defaultValue = "defaultValue";
    testIfDocumentIsFocused('value "false"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { defaultValue }));
      const input = findInput(container);
      input.focus();
      expect(input.node.value).toEqual(defaultValue);
    });
    testIfDocumentIsFocused('value "true"', () => {
      const { container } = (0, import_react.render)(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { clearTextOnFocus: true, defaultValue })
      );
      const input = findInput(container);
      input.focus();
      expect(input.node.value).toEqual("");
    });
  });
  test('prop "defaultValue"', () => {
    const defaultValue = "defaultValue";
    const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { defaultValue }));
    const input = findInput(container);
    expect(input.value).toEqual(defaultValue);
  });
  describe('prop "disabled"', () => {
    test('value "false"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, {}));
      const input = findInput(container);
      expect(input.disabled).toEqual(false);
    });
    test('value "true"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { disabled: true }));
      const input = findInput(container);
      expect(input.disabled).toEqual(true);
    });
  });
  describe('prop "editable"', () => {
    test('value "true"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, {}));
      const input = findInput(container);
      expect(input.readOnly).toEqual(false);
    });
    test('value "false"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { editable: false }));
      const input = findInput(container);
      expect(input.readOnly).toEqual(true);
    });
  });
  describe('prop "keyboardType"', () => {
    test("default value", () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { keyboardType: "default" }));
      const input = findInput(container);
      expect(input.type).toEqual("text");
    });
    test('value "email-address"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { keyboardType: "email-address" }));
      const input = findInput(container);
      expect(input.type).toEqual("email");
    });
    test('value "decimal-pad"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { keyboardType: "decimal-pad" }));
      const input = findInput(container);
      expect(input.inputMode).toEqual("decimal");
    });
    test('value "number-pad"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { keyboardType: "number-pad" }));
      const input = findInput(container);
      expect(input.inputMode).toEqual("numeric");
    });
    test('value "numeric"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { keyboardType: "numeric" }));
      const input = findInput(container);
      expect(input.inputMode).toEqual("numeric");
    });
    test('value "phone-pad"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { keyboardType: "phone-pad" }));
      const input = findInput(container);
      expect(input.type).toEqual("tel");
    });
    test('value "url"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { keyboardType: "url" }));
      const input = findInput(container);
      expect(input.type).toEqual("url");
    });
  });
  test('prop "maxLength"', () => {
    let { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, {}));
    let input = findInput(container);
    expect(input.getAttribute("maxLength")).toEqual(null);
    ({ container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { maxLength: 10 })));
    input = findInput(container);
    expect(input.getAttribute("maxLength")).toEqual("10");
  });
  describe('prop "multiline"', () => {
    test('value "false"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, {}));
      const input = findInput(container);
      expect(input).toBeDefined();
    });
    test('value "true"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { multiline: true }));
      const textarea = findTextArea(container);
      expect(textarea).toBeDefined();
    });
  });
  describe('prop "numberOfLines"', () => {
    test('without "multiline"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { numberOfLines: 2 }));
      const input = findInput(container);
      const textarea = findTextArea(container);
      expect(input).toBeDefined();
      expect(textarea).toBeNull();
    });
    test('with "multiline"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { multiline: true, numberOfLines: 3 }));
      const textarea = findTextArea(container);
      expect(textarea.getAttribute("rows")).toEqual("3");
    });
  });
  test('prop "onBlur"', () => {
    const onBlur = jest.fn();
    const ref = import_react2.default.createRef();
    (0, import_test_utils.act)(() => {
      (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onBlur, ref }));
    });
    const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
    const body = (0, import_dom_event_testing_library.createEventTarget)(document.body);
    (0, import_test_utils.act)(() => {
      target.focus();
      body.focus({ relatedTarget: target.node });
    });
    expect(onBlur).toHaveBeenCalledTimes(1);
    expect(import__.default.State.currentlyFocusedField()).toBe(null);
  });
  test.skip('prop "onChange"', () => {
    const onChange = jest.fn();
    const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onChange }));
    const input = findInput(container);
    input.dispatchEvent(new window.Event("change", { bubbles: true }));
    expect(onChange).toHaveBeenCalledTimes(1);
  });
  test.skip('prop "onChangeText"', () => {
    const onChangeText = jest.fn();
    const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onChangeText }));
    const input = findInput(container);
    input.dispatchEvent(keydown({ key: "a" }));
    input.dispatchEvent(new window.Event("change", { bubbles: true }));
    expect(onChangeText).toHaveBeenCalledTimes(1);
    expect(onChangeText).toBeCalledWith("a");
  });
  test('prop "onFocus"', () => {
    const onFocus = jest.fn();
    const ref = import_react2.default.createRef();
    (0, import_test_utils.act)(() => {
      (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onFocus, ref }));
    });
    const target = (0, import_dom_event_testing_library.createEventTarget)(ref.current);
    (0, import_test_utils.act)(() => {
      target.focus();
    });
    expect(onFocus).toHaveBeenCalledTimes(1);
    target.node.focus();
    expect(import__.default.State.currentlyFocusedField()).toBe(target.node);
  });
  describe('prop "onKeyPress"', () => {
    test("arrow key", () => {
      const onKeyPress = jest.fn((e) => {
        e.persist();
      });
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onKeyPress }));
      const input = findInput(container);
      input.dispatchEvent(keydown({ key: "ArrowLeft" }));
      expect(onKeyPress).toHaveBeenCalledTimes(1);
      expect(onKeyPress).toBeCalledWith(
        expect.objectContaining({
          nativeEvent: expect.objectContaining({
            altKey: false,
            ctrlKey: false,
            key: "ArrowLeft",
            metaKey: false,
            shiftKey: false,
            target: expect.anything()
          })
        })
      );
    });
    test("backspace key", () => {
      const onKeyPress = jest.fn((e) => {
        e.persist();
      });
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onKeyPress }));
      const input = findInput(container);
      input.dispatchEvent(keydown({ key: "Backspace" }));
      expect(onKeyPress).toHaveBeenCalledTimes(1);
      expect(onKeyPress).toBeCalledWith(
        expect.objectContaining({
          nativeEvent: expect.objectContaining({
            altKey: false,
            ctrlKey: false,
            key: "Backspace",
            metaKey: false,
            shiftKey: false,
            target: expect.anything()
          })
        })
      );
    });
    test("enter key", () => {
      const onKeyPress = jest.fn((e) => {
        e.persist();
      });
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onKeyPress }));
      const input = findInput(container);
      input.dispatchEvent(keydown({ key: "Enter" }));
      expect(onKeyPress).toHaveBeenCalledTimes(1);
      expect(onKeyPress).toBeCalledWith(
        expect.objectContaining({
          nativeEvent: expect.objectContaining({
            altKey: false,
            ctrlKey: false,
            key: "Enter",
            metaKey: false,
            shiftKey: false,
            target: expect.anything()
          })
        })
      );
    });
    test("escape key", () => {
      const onKeyPress = jest.fn((e) => {
        e.persist();
      });
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onKeyPress }));
      const input = findInput(container);
      input.dispatchEvent(keydown({ key: "Escape" }));
      expect(onKeyPress).toHaveBeenCalledTimes(1);
      expect(onKeyPress).toBeCalledWith(
        expect.objectContaining({
          nativeEvent: expect.objectContaining({
            altKey: false,
            ctrlKey: false,
            key: "Escape",
            metaKey: false,
            shiftKey: false,
            target: expect.anything()
          })
        })
      );
    });
    test("space key", () => {
      const onKeyPress = jest.fn((e) => {
        e.persist();
      });
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onKeyPress }));
      const input = findInput(container);
      input.dispatchEvent(keydown({ key: " " }));
      expect(onKeyPress).toHaveBeenCalledTimes(1);
      expect(onKeyPress).toBeCalledWith(
        expect.objectContaining({
          nativeEvent: expect.objectContaining({
            altKey: false,
            ctrlKey: false,
            key: " ",
            metaKey: false,
            shiftKey: false,
            target: expect.anything()
          })
        })
      );
    });
    test("tab key", () => {
      const onKeyPress = jest.fn((e) => {
        e.persist();
      });
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onKeyPress }));
      const input = findInput(container);
      input.dispatchEvent(keydown({ key: "Tab" }));
      expect(onKeyPress).toHaveBeenCalledTimes(1);
      expect(onKeyPress).toBeCalledWith(
        expect.objectContaining({
          nativeEvent: expect.objectContaining({
            altKey: false,
            ctrlKey: false,
            key: "Tab",
            metaKey: false,
            shiftKey: false,
            target: expect.anything()
          })
        })
      );
    });
    test("text key", () => {
      const onKeyPress = jest.fn((e) => {
        e.persist();
      });
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onKeyPress }));
      const input = findInput(container);
      input.dispatchEvent(keydown({ key: "a" }));
      expect(onKeyPress).toHaveBeenCalledTimes(1);
      expect(onKeyPress).toBeCalledWith(
        expect.objectContaining({
          nativeEvent: expect.objectContaining({
            altKey: false,
            ctrlKey: false,
            key: "a",
            metaKey: false,
            shiftKey: false,
            target: expect.anything()
          })
        })
      );
    });
    test("modifier keys are included", () => {
      const onKeyPress = jest.fn((e) => {
        e.persist();
      });
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onKeyPress }));
      const input = findInput(container);
      input.dispatchEvent(
        keydown({
          altKey: true,
          ctrlKey: true,
          metaKey: true,
          shiftKey: true,
          key: " "
        })
      );
      expect(onKeyPress).toHaveBeenCalledTimes(1);
      expect(onKeyPress).toBeCalledWith(
        expect.objectContaining({
          nativeEvent: expect.objectContaining({
            altKey: true,
            ctrlKey: true,
            key: " ",
            metaKey: true,
            shiftKey: true,
            target: expect.anything()
          })
        })
      );
    });
    test('meta key + Enter calls "onKeyPress"', () => {
      const onKeyPress = jest.fn((e) => {
        e.persist();
      });
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onKeyPress }));
      const input = findInput(container);
      input.dispatchEvent(
        keydown({
          metaKey: true,
          key: "Enter"
        })
      );
      expect(onKeyPress).toHaveBeenCalledTimes(1);
    });
  });
  describe('prop "onSelectionChange"', () => {
    test("is called on select", () => {
      const { container } = (0, import_react.render)(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { defaultValue: "12345", onSelectionChange })
      );
      const input = findInput(container);
      input.selectionStart = 0;
      input.selectionEnd = 3;
      input.dispatchEvent(new window.Event("select", {}));
      function onSelectionChange(e) {
        expect(e.nativeEvent.selection.end).toEqual(3);
        expect(e.nativeEvent.selection.start).toEqual(0);
      }
    });
    test.skip("is called on change", () => {
      const onSelectionChange = jest.fn();
      const { container } = (0, import_react.render)(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { onSelectionChange })
      );
      const input = findInput(container);
      input.dispatchEvent(new window.Event("input", { bubbles: true }));
      expect(onSelectionChange).toHaveBeenCalledTimes(1);
    });
  });
  describe('prop "onSubmitEditing"', () => {
    test("single-line input", (done) => {
      const { container } = (0, import_react.render)(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { defaultValue: "12345", onSubmitEditing })
      );
      const input = findInput(container);
      input.dispatchEvent(keydown({ key: "Enter" }));
      function onSubmitEditing(e) {
        expect(e.nativeEvent.target).toBeDefined();
        expect(e.nativeEvent.text).toBe("12345");
        done();
      }
    });
    test("single-line input while composing", () => {
      const onSubmitEditing = jest.fn();
      const { container } = (0, import_react.render)(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { defaultValue: "12345", onSubmitEditing })
      );
      const input = findInput(container);
      input.dispatchEvent(keydown({ key: "Enter", isComposing: true, keyCode: 13 }));
      input.dispatchEvent(
        keydown({ key: "Enter", isComposing: false, keyCode: 229 })
      );
      expect(onSubmitEditing).not.toHaveBeenCalled();
    });
    test("multi-line input", () => {
      const onSubmitEditing = jest.fn();
      const { container } = (0, import_react.render)(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import__.default,
          {
            defaultValue: "12345",
            multiline: true,
            onSubmitEditing
          }
        )
      );
      const textarea = findTextArea(container);
      textarea.dispatchEvent(keydown({ key: "Enter" }));
      expect(onSubmitEditing).not.toHaveBeenCalled();
    });
    test('multi-line input with "blurOnSubmit" triggers "onSubmitEditing"', () => {
      const onSubmitEditing = jest.fn();
      const preventDefault = jest.fn();
      const { container } = (0, import_react.render)(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          import__.default,
          {
            blurOnSubmit: true,
            defaultValue: "12345",
            multiline: true,
            onSubmitEditing
          }
        )
      );
      const textarea = findTextArea(container);
      textarea.dispatchEvent(
        keydown({ key: "Enter", preventDefault, shiftKey: true })
      );
      expect(onSubmitEditing).not.toHaveBeenCalledWith(
        expect.objectContaining({ shiftKey: true })
      );
      expect(preventDefault).not.toHaveBeenCalled();
      textarea.dispatchEvent(keydown({ key: "Enter", preventDefault }));
      expect(onSubmitEditing).toHaveBeenCalledTimes(1);
      expect(preventDefault).toHaveBeenCalledTimes(1);
    });
  });
  test('prop "returnKeyType"', () => {
    const returnKeyType = "previous";
    const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { returnKeyType }));
    const input = findInput(container);
    expect(input.getAttribute("enterkeyhint")).toEqual(returnKeyType);
  });
  test('prop "secureTextEntry"', () => {
    let { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { secureTextEntry: true }));
    const input = findInput(container);
    expect(input.getAttribute("type")).toEqual("password");
    ({ container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { multiline: true, secureTextEntry: true })));
    const textarea = findTextArea(container);
    expect(textarea.getAttribute("type")).toEqual(null);
  });
  describe('prop "selectTextOnFocus"', () => {
    testIfDocumentIsFocused('value "false"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { defaultValue: "text" }));
      const input = findInput(container);
      input.focus();
      expect(input.selectionEnd).toEqual(4);
      expect(input.selectionStart).toEqual(4);
    });
  });
  describe('prop "selection"', () => {
    test("set cursor location", () => {
      const cursorLocation = { start: 3, end: 3 };
      const { container: defaultContainer } = (0, import_react.render)(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { defaultValue: "12345" })
      );
      const inputDefaultSelection = findInput(defaultContainer);
      expect(inputDefaultSelection.selectionStart).toEqual(5);
      expect(inputDefaultSelection.selectionEnd).toEqual(5);
      const { container: customContainer } = (0, import_react.render)(
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { defaultValue: "12345", selection: cursorLocation })
      );
      const inputCustomSelection = findInput(customContainer);
      expect(inputCustomSelection.selectionStart).toEqual(cursorLocation.start);
      expect(inputCustomSelection.selectionEnd).toEqual(cursorLocation.end);
    });
  });
  describe('prop "spellCheck"', () => {
    test("default value", () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, {}));
      const input = findInput(container);
      expect(input.getAttribute("spellCheck")).toEqual("true");
    });
    test('inherit from "autoCorrect"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { autoCorrect: false }));
      const input = findInput(container);
      expect(input.getAttribute("spellCheck")).toEqual("false");
    });
    test('value "false"', () => {
      const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { spellCheck: false }));
      const input = findInput(container);
      expect(input.getAttribute("spellCheck")).toEqual("false");
    });
  });
  test('prop "value"', () => {
    const value = "value";
    const { container } = (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { value }));
    const input = findInput(container);
    expect(input.value).toEqual(value);
  });
  describe("imperative methods", () => {
    test("node.clear()", () => {
      const ref = import_react2.default.createRef();
      (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { ref }));
      expect(typeof ref.current.clear).toBe("function");
    });
    test("node.isFocused()", () => {
      const ref = import_react2.default.createRef();
      (0, import_react.render)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import__.default, { ref }));
      expect(typeof ref.current.isFocused).toBe("function");
    });
  });
});
//# sourceMappingURL=index-test.js.map
