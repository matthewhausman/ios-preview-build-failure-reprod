"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var useAnimatedProps_exports = {};
__export(useAnimatedProps_exports, {
  default: () => useAnimatedProps
});
module.exports = __toCommonJS(useAnimatedProps_exports);
var import_createForOfIteratorHelperLoose = __toESM(require("@babel/runtime/helpers/createForOfIteratorHelperLoose"));
var import_react = require("react");
var import_useRefEffect = __toESM(require("../useRefEffect"));
var import_AnimatedEvent = require("./AnimatedEvent");
var import_NativeAnimatedHelper = __toESM(require("./NativeAnimatedHelper"));
var import_AnimatedProps = __toESM(require("./nodes/AnimatedProps"));
const useLayoutEffect = typeof window === "undefined" ? import_react.useEffect : import_react.useLayoutEffect;
function useAnimatedProps(props) {
  var _useReducer = (0, import_react.useReducer)((count) => count + 1, 0), scheduleUpdate = _useReducer[1];
  var onUpdateRef = (0, import_react.useRef)(null);
  var node = (0, import_react.useMemo)(
    () => new import_AnimatedProps.default(
      props,
      () => onUpdateRef.current == null ? void 0 : onUpdateRef.current()
    ),
    [props]
  );
  useAnimatedPropsLifecycle(node);
  var refEffect = (0, import_react.useCallback)(
    (instance) => {
      node.setNativeView(instance);
      onUpdateRef.current = () => {
        (0, import_react.startTransition)(() => {
          scheduleUpdate();
        });
      };
      var target = getEventTarget(instance);
      var events = [];
      for (var propName in props) {
        var propValue = props[propName];
        if (propValue instanceof import_AnimatedEvent.AnimatedEvent && propValue.__isNative) {
          propValue.__attach(target, propName);
          events.push([propName, propValue]);
        }
      }
      return () => {
        onUpdateRef.current = null;
        for (var _iterator = (0, import_createForOfIteratorHelperLoose.default)(events), _step; !(_step = _iterator()).done; ) {
          var _step$value = _step.value, _propName = _step$value[0], _propValue = _step$value[1];
          _propValue.__detach(target, _propName);
        }
      };
    },
    [props, node]
  );
  var callbackRef = (0, import_useRefEffect.default)(refEffect);
  return [reduceAnimatedProps(node), callbackRef];
}
function reduceAnimatedProps(node) {
  return {
    ...node.__getValue(),
    collapsable: false
  };
}
function useAnimatedPropsLifecycle(node) {
  var prevNodeRef = (0, import_react.useRef)(null);
  var isUnmountingRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    import_NativeAnimatedHelper.default.API.flushQueue();
  });
  useLayoutEffect(() => {
    isUnmountingRef.current = false;
    return () => {
      isUnmountingRef.current = true;
    };
  }, []);
  useLayoutEffect(() => {
    node.__attach();
    if (prevNodeRef.current != null) {
      var prevNode = prevNodeRef.current;
      prevNode.__restoreDefaultValues();
      prevNode.__detach();
      prevNodeRef.current = null;
    }
    return () => {
      if (isUnmountingRef.current) {
        node.__detach();
      } else {
        prevNodeRef.current = node;
      }
    };
  }, [node]);
}
function getEventTarget(instance) {
  return typeof instance === "object" && typeof (instance == null ? void 0 : instance.getScrollableNode) === "function" ? instance.getScrollableNode() : instance;
}
function isFabricInstance(instance) {
  var _instance$getScrollRe;
  return hasFabricHandle(instance) || // Some components have a setNativeProps function but aren't a host component
  // such as lists like FlatList and SectionList. These should also use
  // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying
  // host component. This crazy hack is essentially special casing those lists and
  // ScrollView itself to use forceUpdate in Fabric.
  // If these components end up using forwardRef then these hacks can go away
  // as instance would actually be the underlying host component and the above check
  // would be sufficient.
  hasFabricHandle(
    instance == null ? void 0 : instance.getNativeScrollRef == null ? void 0 : instance.getNativeScrollRef()
  ) || hasFabricHandle(
    instance == null ? void 0 : instance.getScrollResponder == null ? void 0 : (_instance$getScrollRe = instance.getScrollResponder()) == null ? void 0 : _instance$getScrollRe.getNativeScrollRef == null ? void 0 : _instance$getScrollRe.getNativeScrollRef()
  );
}
function hasFabricHandle(instance) {
  var _instance$_internalIn, _instance$_internalIn2;
  return (instance == null ? void 0 : (_instance$_internalIn = instance["_internalInstanceHandle"]) == null ? void 0 : (_instance$_internalIn2 = _instance$_internalIn.stateNode) == null ? void 0 : _instance$_internalIn2.canonical) != null;
}
//# sourceMappingURL=useAnimatedProps.js.map
